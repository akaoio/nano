src/main.c:void signal_handler(int sig) {
src/main.c:int main(int argc, char *argv[]) {
src/libs/rkllm/rkllm.h:typedef int(*LLMResultCallback)(RKLLMResult* result, void* userdata, LLMCallState state);
src/libs/rkllm/rkllm.h:RKLLMParam rkllm_createDefaultParam();
src/libs/rkllm/rkllm.h:int rkllm_init(LLMHandle* handle, RKLLMParam* param, LLMResultCallback callback);
src/libs/rkllm/rkllm.h:int rkllm_load_lora(LLMHandle handle, RKLLMLoraAdapter* lora_adapter);
src/libs/rkllm/rkllm.h:int rkllm_load_prompt_cache(LLMHandle handle, const char* prompt_cache_path);
src/libs/rkllm/rkllm.h:int rkllm_release_prompt_cache(LLMHandle handle);
src/libs/rkllm/rkllm.h:int rkllm_destroy(LLMHandle handle);
src/libs/rkllm/rkllm.h:int rkllm_run(LLMHandle handle, RKLLMInput* rkllm_input, RKLLMInferParam* rkllm_infer_params, void* userdata);
src/libs/rkllm/rkllm.h:int rkllm_run_async(LLMHandle handle, RKLLMInput* rkllm_input, RKLLMInferParam* rkllm_infer_params, void* userdata);
src/libs/rkllm/rkllm.h:int rkllm_abort(LLMHandle handle);
src/libs/rkllm/rkllm.h:int rkllm_is_running(LLMHandle handle);
src/libs/rkllm/rkllm.h:int rkllm_clear_kv_cache(LLMHandle handle, int keep_system_prompt, int* start_pos, int* end_pos);
src/libs/rkllm/rkllm.h:int rkllm_get_kv_cache_size(LLMHandle handle, int* cache_sizes);
src/libs/rkllm/rkllm.h:int rkllm_set_chat_template(LLMHandle handle, const char* system_prompt, const char* prompt_prefix, const char* prompt_postfix);
src/libs/rkllm/rkllm.h:int rkllm_set_function_tools(LLMHandle handle, const char* system_prompt, const char* tools, const char* tool_response_str);
src/libs/rkllm/rkllm.h:int rkllm_set_cross_attn_params(LLMHandle handle, RKLLMCrossAttnParam* cross_attn_params);
src/io/model_version.h:int model_inspect_version(const char* model_path, model_version_info_t* version_info);
src/io/model_version.h:int model_check_compatibility(const char* model_path, compatibility_result_t* result);
src/io/model_version.h:int model_check_lora_compatibility(const char* base_model_path, const char* lora_adapter_path, compatibility_result_t* result);
src/io/model_version.h:const char* get_runtime_version_string(void);
src/io/worker_pool.c:static void* worker_thread(void* arg) {
src/io/worker_pool.c:int worker_pool_init(worker_pool_t* pool, queue_t* req_q, queue_t* resp_q) {
src/io/worker_pool.c:void worker_pool_shutdown(worker_pool_t* pool) {
src/io/handle_pool.h:int handle_pool_init(handle_pool_t* pool);
src/io/handle_pool.h:uint32_t handle_pool_create(handle_pool_t* pool, const char* model_path);
src/io/handle_pool.h:int handle_pool_destroy(handle_pool_t* pool, uint32_t handle_id);
src/io/handle_pool.h:LLMHandle* handle_pool_get(handle_pool_t* pool, uint32_t handle_id);
src/io/handle_pool.h:bool handle_pool_is_valid(handle_pool_t* pool, uint32_t handle_id);
src/io/handle_pool.h:size_t handle_pool_get_memory_usage(handle_pool_t* pool, uint32_t handle_id);
src/io/handle_pool.h:size_t handle_pool_get_total_memory(handle_pool_t* pool);
src/io/handle_pool.h:int handle_pool_cleanup(handle_pool_t* pool);
src/io/worker_pool.h:int worker_pool_init(worker_pool_t* pool, queue_t* req_q, queue_t* resp_q);
src/io/worker_pool.h:void worker_pool_shutdown(worker_pool_t* pool);
src/io/handle_pool.c:int handle_pool_init(handle_pool_t* pool) {
src/io/handle_pool.c:uint32_t handle_pool_create(handle_pool_t* pool, const char* model_path) {
src/io/handle_pool.c:int handle_pool_destroy(handle_pool_t* pool, uint32_t handle_id) {
src/io/handle_pool.c:LLMHandle* handle_pool_get(handle_pool_t* pool, uint32_t handle_id) {
src/io/handle_pool.c:bool handle_pool_is_valid(handle_pool_t* pool, uint32_t handle_id) {
src/io/handle_pool.c:size_t handle_pool_get_memory_usage(handle_pool_t* pool, uint32_t handle_id) {
src/io/handle_pool.c:size_t handle_pool_get_total_memory(handle_pool_t* pool) {
src/io/handle_pool.c:int handle_pool_cleanup(handle_pool_t* pool) {
src/io/io.h:int io_init(void);
src/io/io.h:int io_push_request(const char* json_request);
src/io/io.h:int io_pop_response(char* json_response, size_t max_len);
src/io/io.h:void io_shutdown(void);
src/io/system_info.c:int system_detect(system_info_t* info) {
src/io/system_info.c:int model_analyze(const char* model_path, const system_info_t* sys_info, model_info_t* model_info) {
src/io/system_info.c:int system_can_load_model(const system_info_t* sys_info, const model_info_t* model_info) {
src/io/system_info.c:int system_force_gc(void) {
src/io/system_info.c:int system_free_memory(void) {
src/io/system_info.c:int system_refresh_memory_info(system_info_t* info) {
src/io/queue.c:int queue_init(queue_t* q) {
src/io/queue.c:int queue_push(queue_t* q, const queue_item_t* item) {
src/io/queue.c:int queue_pop(queue_t* q, queue_item_t* item) {
src/io/queue.c:int queue_empty(const queue_t* q) {
src/io/queue.c:int queue_full(const queue_t* q) {
src/io/queue.c:int queue_size(const queue_t* q) {
src/io/queue.c:void queue_item_cleanup(queue_item_t* item) {
src/io/queue.h:int queue_init(queue_t* q);
src/io/queue.h:int queue_push(queue_t* q, const queue_item_t* item);
src/io/queue.h:int queue_pop(queue_t* q, queue_item_t* item);
src/io/queue.h:int queue_empty(const queue_t* q);
src/io/queue.h:int queue_full(const queue_t* q);
src/io/queue.h:int queue_size(const queue_t* q);
src/io/queue.h:void queue_item_cleanup(queue_item_t* item);
src/io/operations/json_utils.c:const char* json_get_string(const char* json, const char* key, char* buffer, size_t buffer_size) {
src/io/operations/json_utils.c:int json_get_int(const char* json, const char* key, int default_val) {
src/io/operations/json_utils.c:double json_get_double(const char* json, const char* key, double default_val) {
src/io/operations/method_run.c:int method_run(uint32_t handle_id, const char* params, char* result, size_t result_size) {
src/io/operations/dispatcher.c:int execute_method(const char* method, uint32_t handle_id, const char* params, char* result, size_t result_size) {
src/io/operations/callback.c:int inference_callback(RKLLMResult* result, void* userdata, LLMCallState state) {
src/io/operations/method_init.c:int method_init(uint32_t handle_id, const char* params, char* result, size_t result_size) {
src/io/operations/method_lora.c:int method_lora_init(uint32_t handle_id, const char* params, char* result, size_t result_size) {
src/io/operations/operations.h:typedef int (*operation_func_t)(uint32_t handle_id, const char* params, char* result, size_t result_size);
src/io/operations/operations.h:int execute_method(const char* method, uint32_t handle_id, const char* params, char* result, size_t result_size);
src/io/operations/operations.h:int method_init(uint32_t handle_id, const char* params, char* result, size_t result_size);
src/io/operations/operations.h:int method_lora_init(uint32_t handle_id, const char* params, char* result, size_t result_size);
src/io/operations/operations.h:int method_run(uint32_t handle_id, const char* params, char* result, size_t result_size);
src/io/operations/operations.h:int method_destroy(uint32_t handle_id, const char* params, char* result, size_t result_size);
src/io/operations/operations.h:int method_status(uint32_t handle_id, const char* params, char* result, size_t result_size);
src/io/operations/operations.h:const char* json_get_string(const char* json, const char* key, char* buffer, size_t buffer_size);
src/io/operations/operations.h:int json_get_int(const char* json, const char* key, int default_val);
src/io/operations/operations.h:double json_get_double(const char* json, const char* key, double default_val);
src/io/operations/operations.h:int inference_callback(RKLLMResult* result, void* userdata, LLMCallState state);
src/io/operations/method_basic.c:int method_destroy(uint32_t handle_id, const char* params, char* result, size_t result_size) {
src/io/operations/method_basic.c:int method_status(uint32_t handle_id, const char* params, char* result, size_t result_size) {
src/io/io.c:static void* worker_thread(void* arg) {
src/io/io.c:int io_init(void) {
src/io/io.c:int io_push_request(const char* json_request) {
src/io/io.c:int io_pop_response(char* json_response, size_t max_len) {
src/io/io.c:void io_shutdown(void) {
src/io/system_info.h:int system_detect(system_info_t* info);
src/io/system_info.h:int model_analyze(const char* model_path, const system_info_t* sys_info, model_info_t* model_info);
src/io/system_info.h:int system_can_load_model(const system_info_t* sys_info, const model_info_t* model_info);
src/io/system_info.h:int system_force_gc(void);
src/io/system_info.h:int system_free_memory(void);
src/io/system_info.h:int system_refresh_memory_info(system_info_t* info);
src/io/model_version.c:int extract_model_version(const char* model_path, model_version_info_t* version) {
src/io/model_version.c:int model_check_compatibility(const char* model_path, compatibility_result_t* result) {
src/io/model_version.c:int model_check_lora_compatibility(const char* base_model_path, const char* lora_path, compatibility_result_t* result) {
src/io/model_version.c:const char* get_runtime_version_string(void) {
